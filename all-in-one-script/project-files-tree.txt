File: /home/lamine/all-in-one-script/Dockerfile
Content:
FROM python:3.8-slim-buster

WORKDIR /app

COPY requirements.txt requirements.txt
RUN pip install -r requirements.txt

COPY app /app

CMD ["python", "app.py"]
\n\n
File: /home/lamine/all-in-one-script/project_contents.txt
Content:
File: /home/lamine/all-in-one-script/docker-compose.yml
Content:
version: '3'
services:
  web:
    build: .
    ports:
      - "5000:5000"
    volumes:
      - ./app:/app
    environment:
      - FLASK_ENV=development
\n\n
File: /home/lamine/all-in-one-script/requirements.txt
Content:
Flask==2.0.1
Werkzeug==2.0.1
requests==2.26.0
beautifulsoup4==4.10.0
pytube==11.0.1
PyGithub==1.55
httpx==0.23.0

\n\n
File: /home/lamine/all-in-one-script/app/app.py
Content:
from flask import Flask, render_template, request, jsonify
from script_handler import run_youtube_to_github_handler, run_channel_scrapper_handler, upload_to_github_handler

app = Flask(__name__)

# ... (rest of the code)

@app.route('/run_script', methods=['POST'])
def run_script():
    global current_progress, status_message, result_content
    data = request.json
    script_type = data['script_type']

    def progress_callback(progress, message):
        global current_progress, status_message
        current_progress = progress
        status_message = message

    data['progress_callback'] = progress_callback

    try:
        if script_type == 'youtube-to-github':
            result = run_youtube_to_github_handler(data)
        elif script_type == 'channel-scrapper':
            result = run_channel_scrapper_handler(data)
            result_content = result.get('content', '')
        else:
            return jsonify({'error': 'Invalid script type'})

        result['content'] = result_content
        return jsonify(result)

    except Exception as e:
        return jsonify({'error': str(e)})  # Return the error message to the frontend

# ... (rest of the code)
\n\n
File: /home/lamine/all-in-one-script/app/static/css/style.css
Content:
body {
    font-family: Arial, sans-serif;
    line-height: 1.6;
    margin: 0;
    padding: 20px;
    background-color: #f4f4f4;
}

h1 {
    color: #333;
}

input[type="text"], input[type="password"], select, textarea {
    width: 100%;
    padding: 8px;
    margin-bottom: 10px;
    border: 1px solid #ddd;
    border-radius: 4px;
}

button {
    background-color: #4CAF50;
    color: white;
    padding: 10px 15px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}

button:hover {
    background-color: #45a049;
}

#progressBar {
    margin-top: 20px;
}

progress {
    width: 100%;
}

#statusMessage {
    margin-top: 10px;
    font-style: italic;
}
\n\n
File: /home/lamine/all-in-one-script/app/static/js/script.js
Content:
// ... (rest of the code)

fetch('/run_script', {
    // ... (fetch options)
})
.then(response => response.json())
.then(data => {
    if (data.error) {
        updateProgress(100, data.error); // Display error in the progress area
    } else {
        updateProgress(data.progress, data.message);
        // ... (rest of the success handling)
    }
})
.catch((error) => {
    updateProgress(100, "An unexpected error occurred."); // Handle fetch errors
});

// ... (rest of the code)
\n\n
File: /home/lamine/all-in-one-script/app/youtube_to_github.py
Content:
import re
import logging
from github import Github, GithubException
from pytube import Playlist, exceptions

logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")

def run_youtube_to_github_script(playlist_url, github_username, github_repo, github_token, progress_callback):
    try:
        # ... (playlist fetching and video processing logic)

        playlist_name = playlist.title
        file_name = f"{playlist_name}.m3u"

        # ... (GitHub connection and file handling)

        try:
            # ... (check if file exists and update/create logic)
        except GithubException as e:  # Corrected indentation
            logging.error(f"GitHub Error: {e}")
            return {"progress": 100, "message": f"An error occurred while updating/creating the file on GitHub: {str(e)}"}

    except exceptions.RegexMatchError:
        logging.error(f"Invalid playlist URL: {playlist_url}")
        return {"progress": 100, "message": f"Invalid playlist URL: {playlist_url}. Please check the format."}
    except KeyError:
        logging.error(f"Error extracting video information: {playlist_url}")
        return {"progress": 100, "message": f"Error extracting video information from the playlist: {playlist_url}"}
    except Exception as e:
        logging.error(f"Unexpected error: {e}")
        return {"progress": 100, "message": f"An unexpected error occurred: {str(e)}"}
\n\n
File: /home/lamine/all-in-one-script/app/channel_scrapper.py
Content:
import asyncio
import httpx
import re
from bs4 import BeautifulSoup

async def fetch_content(url):
    async with httpx.AsyncClient() as client:
        try:
            response = await client.get(url, timeout=10.0)
            return response.text
        except Exception as e:
            print(f"Error fetching {url}: {str(e)}")
            return ""

async def verify_stream(url):
    async with httpx.AsyncClient() as client:
        try:
            response = await client.head(url, timeout=5.0)
            return response.status_code == 200
        except:
            return False

def extract_channel_name(info):
    name = re.search(r'tvg-name="([^"]*)"', info)
    if name and name.group(1):
        return name.group(1)
    name = re.search(r'group-title="([^"]*)"', info)
    if name and name.group(1):
        return name.group(1)
    name = re.search(r',(.+)$', info)
    if name and name.group(1):
        return name.group(1).strip()
    return "Unknown Channel"

async def process_m3u(content):
    matches = re.findall(r'(#EXTINF:-1[^\n]*)\n(https?://[^\s]+\.m3u8)', content)
    all_streams = {url: (extract_channel_name(info), info) for info, url in matches}
    return all_streams

async def process_html(content):
    soup = BeautifulSoup(content, 'html.parser')
    all_streams = {}
    for a in soup.find_all('a', href=True):
        if a['href'].endswith('.m3u8'):
            all_streams[a['href']] = (a.text.strip() or "Unknown Channel", f"#EXTINF:-1,{a.text.strip()}")
    return all_streams

async def process_playlist(url, progress_callback):
    content = await fetch_content(url)
    all_streams = await process_m3u(content) or await process_html(content)
    
    verified_streams = []
    total = len(all_streams)
    
    for i, (url, (name, info)) in enumerate(all_streams.items()):
        if await verify_stream(url):
            verified_streams.append((name, url, info))
        progress = int((i + 1) / total * 100)
        progress_callback(progress, f"Processed {i + 1}/{total} streams from {url}")
    
    return verified_streams

async def run_channel_scrapper_script_async(website_urls, progress_callback):
    all_verified_streams = []
    total_urls = len(website_urls)
    
    for i, url in enumerate(website_urls):
        verified_streams = await process_playlist(url, progress_callback)
        all_verified_streams.extend(verified_streams)
        progress = int((i + 1) / total_urls * 100)
        progress_callback(progress, f"Processed {i + 1}/{total_urls} websites")
    
    m3u_content = "#EXTM3U\n"
    for name, url, info in all_verified_streams:
        m3u_content += f"{info}\n{url}\n"
    
    return {'progress': 100, 'message': f'Channels successfully scraped with {len(all_verified_streams)} verified streams', 'content': m3u_content}

def run_channel_scrapper_script(website_urls, progress_callback):
    return asyncio.run(run_channel_scrapper_script_async(website_urls, progress_callback))
\n\n
File: /home/lamine/all-in-one-script/app/templates/index.html
Content:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>All-in-One Script Interface</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>
<body>
    <h1>All-in-One Script Interface</h1>
    
    <select id="scriptSelector" onchange="updateFields()">
        <option value="youtube-to-github">YouTube to GitHub</option>
        <option value="channel-scrapper">Channel Scrapper M3U</option>
    </select>

    <div id="youtubeToGithubFields">
        <input type="text" id="playlistUrl" placeholder="YouTube Playlist URL">
        <input type="text" id="githubUsername" placeholder="GitHub Username">
        <input type="text" id="githubRepo" placeholder="GitHub Repository">
        <input type="password" id="githubToken" placeholder="GitHub Token">
    </div>

    <div id="channelScrapperFields" style="display:none;">
        <textarea id="websiteUrls" placeholder="Enter website URLs (one per line)"></textarea>
        <input type="text" id="scrapperGithubUsername" placeholder="GitHub Username">
        <input type="text" id="scrapperGithubRepo" placeholder="GitHub Repository">
        <input type="password" id="scrapperGithubToken" placeholder="GitHub Token">
    </div>

    <button onclick="runScript()">Run Script</button>

    <div id="progressBar" style="display:none;">
        <progress id="progress" value="0" max="100"></progress>
        <p id="statusMessage"></p>
    </div>

    <div id="resultArea" style="display:none;">
        <h2>Result</h2>
        <pre id="resultContent"></pre>
        <button onclick="downloadResult()">Download M3U File</button>
        <button onclick="uploadToGithub()">Upload to GitHub</button>
    </div>

    <script src="{{ url_for('static', filename='js/script.js') }}"></script>
</body>
</html>
\n\n
File: /home/lamine/all-in-one-script/app/script_handler.py
Content:
from youtube_to_github import run_youtube_to_github_script
from channel_scrapper import run_channel_scrapper_script
from github import Github
from github import GithubException

def run_youtube_to_github_handler(params):
    return run_youtube_to_github_script(
        params['playlist_url'],
        params['github_username'],
        params['github_repo'],
        params['github_token'],
        params['progress_callback']
    )

def run_channel_scrapper_handler(params):
    return run_channel_scrapper_script(
        params['website_urls'].split('\n'),
        params['progress_callback']
    )

def upload_to_github_handler(params):
    try:
        g = Github(params['github_token'])
        repo = g.get_user(params['github_username']).get_repo(params['github_repo'])
        file_name = 'channels.m3u' if params['script_type'] == 'channel-scrapper_upload' else 'playlist.m3u'
        
        try:
            contents = repo.get_contents(file_name)
            repo.update_file(contents.path, "Update M3U file", params['content'], contents.sha)
            return {"status": "success", "message": f"File '{file_name}' updated on GitHub."}
        except GithubException as e:
            if e.status == 404:
                repo.create_file(file_name, "Add M3U file", params['content'])
                return {"status": "success", "message": f"File '{file_name}' created on GitHub."}
            else:
                return {"status": "error", "message": f"An error occurred while updating/creating the file on GitHub: {str(e)}"}
    except Exception as e:
        return {"status": "error", "message": f"An unexpected error occurred: {str(e)}"}
\n\n
File: /home/lamine/all-in-one-script/app/__init__.py
Content:
\n\n
